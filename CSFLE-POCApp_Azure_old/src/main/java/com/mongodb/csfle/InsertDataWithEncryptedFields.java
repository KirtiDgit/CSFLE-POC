package com.mongodb.csfle;
/*
 * Copyright 2008-present MongoDB, Inc.

 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */


import static com.mongodb.client.model.Filters.eq;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.sql.Array;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

import org.bson.BsonString;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

import com.fasterxml.jackson.databind.MappingIterator;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.mongodb.ConnectionString;
import com.mongodb.DBObject;
import com.mongodb.client.FindIterable;
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.model.UpdateOptions;
import com.mongodb.csfle.util.CSFLEHelpers;

/*
 * - Reads master key from file "master-key.txt" in root directory of project
 * - Creates a JSON schema for a specified collection to enable automatic encryption
 * - Creates an encrypted client and upserts a single document
 * - Finds the upserted document with the encrypted client using an encrypted field
 * - Attempts to find the upserted document with the normal client using an encrypted field
 * - Finds the upserted document with the normal client using a non-encrypted field
 */
public class InsertDataWithEncryptedFields {

    /**
     * @param args
     * @throws Exception
     */
    /**
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        String connectionString = "mongodb://kirti:test@10.0.1.243:27017/admin";
        String keyDb = "admin";
        String keyColl = "__keyVault";
        String keyVaultCollection = String.join(".", keyDb, keyColl);
        String recordsDb = "admin";
        String recordsColl = "Azurepatients";

        String keyId = null; // paste the key generated by DataEncryptionKeyCreator here
        String keyAltName = "demi-Azure-key";
        
        Map<String, Object> masterKeyProperties = new HashMap<>();
        Map<String, Map<String, Object>> kmsProviders = new HashMap<>();
        Map<String, Map<String, Object>> kmsProviderProperties = new HashMap<>();
        
        String kmsProvider = "azure";
        masterKeyProperties.put("provider", kmsProvider);
        masterKeyProperties.put("keyName", "<>");
        masterKeyProperties.put("keyVersion", "<>");
        masterKeyProperties.put("keyVaultEndpoint", "<>");
        Map<String, Object> providerDetails = new HashMap<>();
        providerDetails.put("tenantId", "<>");
        providerDetails.put("clientId", "<>");
        providerDetails.put("clientSecret", "<>");
        //providerDetails.put("identityPlatformEndpoint", "<Azure custom endpoint host>"); // optional
        kmsProviders.put(kmsProvider, providerDetails);
        
        
       // Ensure index exists on key vault
       CSFLEHelpers.createKeyVaultIndex(connectionString, keyDb, keyColl);

       // Find or insert a new data data key
       String encryptionKey = CSFLEHelpers.findDataEncryptionKey(connectionString, keyAltName, keyDb, keyColl);
       
       if (encryptionKey != null) {
           // Print the key
           //System.out.println("Retrieved your existing key. Copy the key below and paste it into InsertDataWithEncryptedFields.java\n" + encryptionKey);
           //System.exit(0);
    	   keyId = encryptionKey;
       }

       else {
			encryptionKey = CSFLEHelpers.createDataEncryptionKey(connectionString, masterKeyProperties,
					kmsProviderProperties, keyVaultCollection, keyAltName);

			// System.out.println("New data increption key has been created\n" +
			// encryptionKey);
			//System.out.println("Data Encryption Key has been created in the database");
			keyId = encryptionKey;
		}

       
            //System.out.println("Congratulations on creating a new data encryption key! Copy the key below and paste it into InsertDataWithEncryptedfields.java\n" + encryptionKey);
   	

       providerDetails.put("tenantId", "<>");
       providerDetails.put("clientId", "<>");
       providerDetails.put("clientSecret", "<>");
       kmsProviders.put(kmsProvider, providerDetails);

        // Construct a JSON Schema
        Document schema = CSFLEHelpers.createJSONSchema(keyId);
       // System.out.println("Schema: " + schema.toJson());

        // Construct an encrypted client
        try (MongoClient encryptedClient =
                CSFLEHelpers.createEncryptedClient(connectionString,
                        kmsProvider,
                        kmsProviders,
                        keyVaultCollection, schema, recordsDb, recordsColl)) {

            // Insert a document into the collection            //Creating a collection object

            MongoCollection<Document> collection = encryptedClient.getDatabase(recordsDb).getCollection(recordsColl);

         //   long timeStamp = System.nanoTime();

            //long start = System.currentTimeMillis();
            //Input file which needs to be parsed
            File input = new File("C:\\Users\\Administrator\\Desktop\\patients_250fields.csv");
             
            CsvSchema csv = CsvSchema.emptySchema().withHeader();
            CsvMapper csvMapper = new CsvMapper();
            List<Document> list = new ArrayList<Document>();
            //
            				MappingIterator<Document> mappingIterator = csvMapper.reader().forType(Document.class).with(csv)
            						.readValues(input);
            				while (mappingIterator.hasNext()) {
            					Document currentDocument = mappingIterator.nextValue();
            					int SSN = Integer.valueOf(currentDocument.remove("SSN").toString());
            					
            					currentDocument.append("SSN", SSN);

            					// System.out.println("current doc: " + currentDocument);
            					list.add(currentDocument);
            				}
//            				
            				long start = System.nanoTime();
            				collection.insertMany(list);
//            				//System.out.println("list: " + list);
            				long end = System.nanoTime();
            				System.out.println("time taken to insert : " + (end-start));
            				

            			
            				long read_start = System.nanoTime();
            				for (int i = 1; i <= 10; i++) {
            					MappingIterator<Document> mappingIterator1 = csvMapper.reader().forType(Document.class).with(csv)
            							.readValues(input);
            					
            					while (mappingIterator1.hasNext()) {

            						Document currentDocument = mappingIterator1.nextValue();

            						int SSN = Integer.valueOf(currentDocument.remove("SSN").toString());

            						Bson ssnQuery = eq("SSN", SSN);
            						
            						Document result = collection.find(ssnQuery).first();
            						
//            						 FindIterable<Document> iterDoc = collection.find();
//            					      Iterator it = iterDoc.iterator();
//            					      while (it.hasNext()) {
//            					         System.out.println("this is it "+it.next());
//            					      }
            					
            						if (result == null) {
            							throw new Exception("No query results were returned, please verify the document was inserted");
            						}
            					     
            					//System.out.println("\nEncrypted client query by the SSN (encrypted) field:\n" + result.toJson()+"\n");
            		               
            							
            					}
            					
            				}
            				long read_end = System.nanoTime();
            				
            				System.out.println("time taken to read : " + (read_end-read_start));
            			    collection.drop();
    }
}
}